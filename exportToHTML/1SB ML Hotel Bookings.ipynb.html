<html>
<head>
<title>1SB ML Hotel Bookings.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
1SB ML Hotel Bookings.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">{ 
 &quot;cells&quot;: [ 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&lt;h1 style=\&quot;text-align: center;\&quot;&gt;Data Science Project&lt;/h1&gt;\n&quot;, 
    &quot;&lt;h2 style=\&quot;text-align: center;\&quot;&gt;Part 1&lt;/h2&gt;\n&quot;, 
    &quot;&lt;h2 style=\&quot;text-align: center;\&quot;&gt;Hotel Booking Demand DataSet&lt;/h2&gt;&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;Section A contains: EDA of Hotel Bookings and ML to Predict Cancellations\n&quot;, 
    &quot;\n&quot;, 
    &quot;Section B contains: Using Different ML Techniques to Improve Prediction Results\n&quot;, 
    &quot;\n&quot;, 
    &quot;If you already read the first section, you may want to skip directly to &lt;a href='#section_b'&gt;Section B&lt;/a&gt;.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%% md\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: 1, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# common imports\n&quot;, 
    &quot;import numpy as np\n&quot;, 
    &quot;import pandas as pd\n&quot;, 
    &quot;import seaborn as sns\n&quot;, 
    &quot;import matplotlib.pyplot as plt\n&quot;, 
    &quot;%matplotlib inline\n&quot;, 
    &quot;\n&quot;, 
    &quot;# machine learning imports\n&quot;, 
    &quot;from sklearn.neighbors import KNeighborsClassifier\n&quot;, 
    &quot;from sklearn.ensemble import RandomForestClassifier\n&quot;, 
    &quot;from sklearn.model_selection import train_test_split\n&quot;, 
    &quot;from sklearn.model_selection import RandomizedSearchCV\n&quot;, 
    &quot;from sklearn.pipeline import Pipeline\n&quot;, 
    &quot;from sklearn.pipeline import TransformerMixin\n&quot;, 
    &quot;from sklearn.preprocessing import MinMaxScaler\n&quot;, 
    &quot;from sklearn.preprocessing import OneHotEncoder\n&quot;, 
    &quot;from sklearn.compose import ColumnTransformer\n&quot;, 
    &quot;from sklearn.impute import SimpleImputer\n&quot;, 
    &quot;from sklearn.base import BaseEstimator\n&quot;, 
    &quot;from sklearn import metrics\n&quot;, 
    &quot;\n&quot;, 
    &quot;# display setup\n&quot;, 
    &quot;pd.set_option(\&quot;display.max_columns\&quot;, None) # the None parameter displays unlimited columns\n&quot;, 
    &quot;sns.set(style=\&quot;whitegrid\&quot;) # for plots&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&lt;a id=\&quot;sectionA\&quot;&gt;&lt;/a&gt;&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%% md\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;## Section A: EDA of Hotel Bookings and ML to Predict Cancellations&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%% md\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 1. Getting the Data&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# read the csv file\n&quot;, 
    &quot;df = pd.read_csv(r\&quot;hotel_bookings.csv\&quot;)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# display the first 5 rows for a quick look\n&quot;, 
    &quot;df.head()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# DataFrame shape (rows, columns)\n&quot;, 
    &quot;# understand the amount of data we are working with\n&quot;, 
    &quot;df.shape&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# description of data\n&quot;, 
    &quot;df.info()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; In a first observation it is clear that some features have\n&quot;, 
    &quot;&gt; missing values (i.e. \&quot;company\&quot; and \&quot;agent\&quot; columns).\n&quot;, 
    &quot;&gt; We will need to take care of this later.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# summary of the numerical attributes\n&quot;, 
    &quot;# null values are ignored\n&quot;, 
    &quot;df.describe()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Features in the DataFrame:\n&quot;, 
    &quot;&gt;&gt; 1. hotel: Resort Hotel or City Hotel\n&quot;, 
    &quot;&gt;&gt; 2. is_canceled: Value indicating if the booking was canceled (1) or not (0)\n&quot;, 
    &quot;&gt;&gt; 3. lead_time: Number of days between the booking date to the arrival date\n&quot;, 
    &quot;&gt;&gt; 4. arrival_date_year: Year of arrival\n&quot;, 
    &quot;&gt;&gt; 5. arrival_date_month: Month of arrival\n&quot;, 
    &quot;&gt;&gt; 6. arrival_date_week_number: Week number according to year of arrival\n&quot;, 
    &quot;&gt;&gt; 7. arrival_date_day_of_month: Day of arrival\n&quot;, 
    &quot;&gt;&gt; 8. stays_in_weekend_nights: Number of weekend nights booked (Saturday or Sunday)\n&quot;, 
    &quot;&gt;&gt; 9. stays_in_week_nights: Number of week nights booked (Monday to Friday)\n&quot;, 
    &quot;&gt;&gt; 10. adults: Number of adults\n&quot;, 
    &quot;&gt;&gt; 11. children: Number of children\n&quot;, 
    &quot;&gt;&gt; 12. babies: Number of babies\n&quot;, 
    &quot;&gt;&gt; 13. meal: Type of meal booked\n&quot;, 
    &quot;&gt;&gt; 14. country: Country of origin\n&quot;, 
    &quot;&gt;&gt; 15. market_segment: Market segment designation, typically influences the price sensitivity\n&quot;, 
    &quot;&gt;&gt; 16. distribution_channel: Booking distribution channel, refers to how the booking was made\n&quot;, 
    &quot;&gt;&gt; 17. is_repeated_guest: Value indication if the booking was from a repeated guest (1) or not (0)\n&quot;, 
    &quot;&gt;&gt; 18. previous_cancellations: Number of previous cancellations prior to current booking\n&quot;, 
    &quot;&gt;&gt; 19. previous_bookings_not_canceled: Number of previous booking not canceled prior to current booking\n&quot;, 
    &quot;&gt;&gt; 20. reserved_room_type: Code of room type reserved\n&quot;, 
    &quot;&gt;&gt; 21. assigned_room_type: Code for the type of room assigned to the booking\n&quot;, 
    &quot;&gt;&gt; 22. booking_changes: Number of changes made to the booking since entering the hotel management system\n&quot;, 
    &quot;&gt;&gt; 23. deposit_type: Type of deposit made for the reservation\n&quot;, 
    &quot;&gt;&gt; 24. agent: ID of the travel agency that made the booking\n&quot;, 
    &quot;&gt;&gt; 25. company: ID of the company/organization that made the booking or is responsible for payment\n&quot;, 
    &quot;&gt;&gt; 26. days_in_waiting_list: Number of days booking was in the waiting list until it was confirmed\n&quot;, 
    &quot;&gt;&gt; 27. customer_type: Type of booking\n&quot;, 
    &quot;&gt;&gt; 28. adr: Average Daily Rate (the sum of transactions divided by the number of nights stayed)\n&quot;, 
    &quot;&gt;&gt; 29. required_car_parking_spaces: Number of car parking spaces requested\n&quot;, 
    &quot;&gt;&gt; 30. total_of_special_requests: Number of special requests made by the customer\n&quot;, 
    &quot;&gt;&gt; 31. reservation_status: Last reservation status (Canceled, Check-Out, No-Show)\n&quot;, 
    &quot;&gt;&gt; 32. reservation_status_date: Date at which the last status was set\n&quot;, 
    &quot;&gt;&gt;\n&quot;, 
    &quot;&gt;&gt;&gt; ##### *Understanding the features could help gain insight on how to treat null values.*&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# a histogram plot for each numerical attribute\n&quot;, 
    &quot;df.hist(bins=50, figsize=(20,15))\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; Initial observations from the histograms:\n&quot;, 
    &quot;&gt;&gt; 1. Some weeks have more bookings. This could be because of holiday or summer seasons, when people tend to travel more.\n&quot;, 
    &quot;&gt;&gt; 2. According to the lead_time plot, most bookings were made shortly before arrival.\n&quot;, 
    &quot;&gt;&gt; 3. Bookings tend to be without children or babies.\n&quot;, 
    &quot;&gt;&gt; 4. It seems that the most accommodations are two weeks long or shorter.\n&quot;, 
    &quot;&gt;&gt; 5. While most bookings were not canceled, there are thousands of instances that were.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; # Objective\n&quot;, 
    &quot;&gt; ## Predicting if a booking will be canceled.\n&quot;, 
    &quot;&gt;&gt; ### Chosen Feature:\n&quot;, 
    &quot;&gt;&gt; #### *is_canceled* column\n&quot;, 
    &quot;&gt;&gt;&gt; 0 means the booking was not canceled\n&quot;, 
    &quot;&gt;&gt;&gt;\n&quot;, 
    &quot;&gt;&gt;&gt; 1 means the booking was canceled\n&quot;, 
    &quot;&gt;&gt; ### Motive:\n&quot;, 
    &quot;&gt;&gt; Like any business, hotels are also looking to gain profit. A model that predicts if the booking\n&quot;, 
    &quot;&gt;&gt; is likely to be canceled could be a good indication for hotels, as they\n&quot;, 
    &quot;&gt;&gt; may prefer to accept the lower risk bookings first.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Splitting the Data:\n&quot;, 
    &quot;&gt;&gt; Before further analysis let's split the data into a training set and a testing set.\n&quot;, 
    &quot;&gt;&gt; This will ensure avoidance of bias that could occur from learning the data as a whole.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# use sklearn train_test_split function to split the data\n&quot;, 
    &quot;# the reason for selecting 0.15 as the test size is because the dataset is very large\n&quot;, 
    &quot;# the random state parameter ensures that data will be shuffled and split the same way in each run\n&quot;, 
    &quot;train_set, test_set = train_test_split(df, test_size=0.15, random_state=42)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;print(\&quot;Number of instances in training set: \&quot;, len(train_set))\n&quot;, 
    &quot;print(\&quot;Number of instances in testing set: \&quot;, len(test_set))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 2. Understanding and Visualizing the Data\n&quot;, 
    &quot;&gt; ##### *The motivation for this section is to gain more insights.*&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# deep copy of the training set\n&quot;, 
    &quot;df2 = train_set.copy()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2.head(2)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Missing Features:&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# the methods below calculate the number of missing values\n&quot;, 
    &quot;missing_values = df2.isna().sum()\n&quot;, 
    &quot;missing_values = missing_values[missing_values != 0]\n&quot;, 
    &quot;missing_values&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# replace missing values\n&quot;, 
    &quot;\n&quot;, 
    &quot;# can assume that there were no children\n&quot;, 
    &quot;df2.fillna({\&quot;children\&quot;: 0}, inplace=True)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# missing countries can be labeled unknown\n&quot;, 
    &quot;df2.fillna({\&quot;country\&quot;: \&quot;Unknown\&quot;}, inplace=True)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# missing agent ID can be zero, presuming the booking was made privately\n&quot;, 
    &quot;df2.fillna({\&quot;agent\&quot;: 0}, inplace=True)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# missing company ID can be zero (for the same reason as agent ID)\n&quot;, 
    &quot;df2.fillna({\&quot;company\&quot;: 0}, inplace=True)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# check that the values were filled\n&quot;, 
    &quot;df2.isna().sum()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Numerical Attributes:&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# method creates a correlations matrix\n&quot;, 
    &quot;corr_matrix = df2.corr()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# looking at attributes correlation with is_canceled feature\n&quot;, 
    &quot;corr_matrix[\&quot;is_canceled\&quot;].sort_values(ascending=False)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# experimenting with attribute combinations\n&quot;, 
    &quot;\n&quot;, 
    &quot;# create a column with total amount of guests\n&quot;, 
    &quot;df2[\&quot;guests_stayed\&quot;] = df2[\&quot;adults\&quot;] + df2[\&quot;children\&quot;] + df2[\&quot;babies\&quot;]\n&quot;, 
    &quot;\n&quot;, 
    &quot;# create a column with total nights booked\n&quot;, 
    &quot;df2[\&quot;nights_stayed\&quot;] = df2[\&quot;stays_in_week_nights\&quot;] + df2[\&quot;stays_in_weekend_nights\&quot;]&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# looking at the correlation matrix again with the added columns\n&quot;, 
    &quot;corr_matrix = df2.corr()\n&quot;, 
    &quot;corr_matrix[\&quot;is_canceled\&quot;].sort_values(ascending=False)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Correlations with is_canceled Attribute - Overview:\n&quot;, 
    &quot;&gt;&gt; The strongest positive correlations (0.1 or more) are:\n&quot;, 
    &quot;&gt;&gt; * lead_time\n&quot;, 
    &quot;&gt;&gt; * previous_cancellations\n&quot;, 
    &quot;&gt;&gt;\n&quot;, 
    &quot;&gt;&gt; The strongest negative correlations (-0.1 or less) are:\n&quot;, 
    &quot;&gt;&gt; * total_of_special_requests\n&quot;, 
    &quot;&gt;&gt; * required_car_parking_spaces\n&quot;, 
    &quot;&gt;&gt; * booking_changes\n&quot;, 
    &quot;&gt;&gt;\n&quot;, 
    &quot;&gt; The attribute combinations tested (guests stayed and nights stayed) both had weak correlations.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Lead Time&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# hist plot of lead time\n&quot;, 
    &quot;# kde = kernel density estimation (displays distribution function, density curve)\n&quot;, 
    &quot;# shows the distribution and highest concentration points\n&quot;, 
    &quot;plt.figure(figsize=(10,5))\n&quot;, 
    &quot;lead_time = df2['lead_time']\n&quot;, 
    &quot;lead_time = pd.DataFrame(sorted(lead_time, reverse = True), columns = ['Lead'])\n&quot;, 
    &quot;sns.histplot(lead_time, kde=True)\n&quot;, 
    &quot;plt.title(\&quot;Lead Time\&quot;, size=20)\n&quot;, 
    &quot;plt.xlabel(\&quot;lead time days\&quot;, size=15)\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# divides lead time by less than 100 days, 100-355 days and 365 or more days\n&quot;, 
    &quot;lead_time_1 = df2[df2[\&quot;lead_time\&quot;] &lt; 100]\n&quot;, 
    &quot;lead_time_2 = df2[(df2[\&quot;lead_time\&quot;] &gt;= 100) &amp; (df2[\&quot;lead_time\&quot;] &lt; 365)]\n&quot;, 
    &quot;lead_time_3 = df2[df2[\&quot;lead_time\&quot;] &gt;= 365]&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# calculates cancellations according to lead time groups\n&quot;, 
    &quot;lead_cancel_1 = lead_time_1[\&quot;is_canceled\&quot;].value_counts()\n&quot;, 
    &quot;lead_cancel_2 = lead_time_2[\&quot;is_canceled\&quot;].value_counts()\n&quot;, 
    &quot;lead_cancel_3 = lead_time_3[\&quot;is_canceled\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# hist plot for each lead time group\n&quot;, 
    &quot;fig, (bx1, bx2, bx3) = plt.subplots(1,3,figsize=(21,6))\n&quot;, 
    &quot;sns.histplot(lead_time_1[\&quot;lead_time\&quot;], ax = bx1, kde=True)\n&quot;, 
    &quot;bx1.set_title(\&quot;lead_time [0,100) days\&quot;, size=20)\n&quot;, 
    &quot;sns.histplot(lead_time_2[\&quot;lead_time\&quot;], ax = bx2, kde=True)\n&quot;, 
    &quot;bx2.set_title(\&quot;lead_time [100,365) days\&quot;, size=20)\n&quot;, 
    &quot;sns.histplot(lead_time_3[\&quot;lead_time\&quot;], ax = bx3, kde=True)\n&quot;, 
    &quot;bx3.set_title(\&quot;lead_time [365,max) days\&quot;, size=20)\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# total count of lead time according to cancellation\n&quot;, 
    &quot;total_lead_days_cancel = pd.DataFrame(data=[lead_cancel_1,lead_cancel_2,lead_cancel_3],\n&quot;, 
    &quot;             index=[\&quot;[0,100) days\&quot;, \&quot;[100,365) days\&quot;, \&quot;[365,max) days\&quot;])\n&quot;, 
    &quot;total_lead_days_cancel&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# pie plot for each lead time group\n&quot;, 
    &quot;fig, ax = plt.subplots(1,3, figsize=(21,6))\n&quot;, 
    &quot;ax[0].pie(np.array([total_lead_days_cancel[0][0], total_lead_days_cancel[1][0]]),\n&quot;, 
    &quot;          labels=[\&quot;not_canceled\&quot;, \&quot;canceled\&quot;], autopct='%1.1f%%', startangle=90,\n&quot;, 
    &quot;          colors=['forestgreen', 'firebrick'])\n&quot;, 
    &quot;ax[0].set_title(\&quot;lead_time [0,100) days\&quot;, size=20)\n&quot;, 
    &quot;ax[1].pie(np.array([total_lead_days_cancel[0][1], total_lead_days_cancel[1][1]]),\n&quot;, 
    &quot;          labels=[\&quot;not_canceled\&quot;, \&quot;canceled\&quot;], autopct='%1.1f%%', startangle=90,\n&quot;, 
    &quot;          colors=['forestgreen', 'firebrick'])\n&quot;, 
    &quot;ax[1].set_title(\&quot;lead_time [100,365) days\&quot;, size=20)\n&quot;, 
    &quot;ax[2].pie(np.array([total_lead_days_cancel[0][2], total_lead_days_cancel[1][2]]),\n&quot;, 
    &quot;          labels=[\&quot;not_canceled\&quot;, \&quot;canceled\&quot;], autopct='%1.1f%%', startangle=90,\n&quot;, 
    &quot;          colors=['forestgreen', 'firebrick'])\n&quot;, 
    &quot;ax[2].set_title(\&quot;lead_time [365,max) days\&quot;, size=20)\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; #### Observations:\n&quot;, 
    &quot;&gt;&gt; * Most bookings occur about 5 days prior to arrival.\n&quot;, 
    &quot;&gt;&gt; * When the lead time is larger the chances for cancellation increase.\n&quot;, 
    &quot;&gt;&gt; * The amount of bookings is steady overall between 20-100 days, then drops.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Previous Cancellations&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# get previous cancellations column\n&quot;, 
    &quot;prev_cancel = df2[\&quot;previous_cancellations\&quot;]&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# sort the index values\n&quot;, 
    &quot;prev_cancel.value_counts().sort_index()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;print(\&quot;Cancellation Rates:\\n\&quot;)\n&quot;, 
    &quot;print('Never canceled =' ,str(round(df2[df2['previous_cancellations']==0]\n&quot;, 
    &quot;                                            ['is_canceled'].mean()*100,2))+' %')\n&quot;, 
    &quot;print('Canceled once =' ,str(round(df2[df2['previous_cancellations']==1]\n&quot;, 
    &quot;                                            ['is_canceled'].mean()*100,2))+' %')\n&quot;, 
    &quot;print('Canceled more than 10 times:',str(round(df2[df2['previous_cancellations']&gt;10]\n&quot;, 
    &quot;                                            ['is_canceled'].mean()*100,2))+' %')\n&quot;, 
    &quot;print('Canceled more than 11 times:' ,str(round(df2[df2['previous_cancellations']&gt;11]\n&quot;, 
    &quot;                                            ['is_canceled'].mean()*100,2))+' %')&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# create a list with previous cancellations indices\n&quot;, 
    &quot;prev_cancel_index = df2[\&quot;previous_cancellations\&quot;].value_counts().index.to_list()\n&quot;, 
    &quot;# sort the list\n&quot;, 
    &quot;prev_cancel_index.sort()\n&quot;, 
    &quot;\n&quot;, 
    &quot;# calculate the average percentage of cancellations for each value in the DataFrame\n&quot;, 
    &quot;percentage_prev_cancel= []\n&quot;, 
    &quot;for i in prev_cancel_index:\n&quot;, 
    &quot;    percentage_prev_cancel.append((round(df2[df2[\&quot;previous_cancellations\&quot;]==i][\&quot;is_canceled\&quot;].mean()*100,2)))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# create a DataFrame with the results\n&quot;, 
    &quot;df_prev_cancel = pd.DataFrame(percentage_prev_cancel, index=prev_cancel_index, columns=[\&quot;Previous Cancellations %\&quot;])\n&quot;, 
    &quot;df_prev_cancel&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# plot previous cancellations by percentages\n&quot;, 
    &quot;df_prev_cancel.plot(figsize= (10,5), linewidth=3)\n&quot;, 
    &quot;plt.title(\&quot;Previous Cancellations\&quot;, size=20)\n&quot;, 
    &quot;plt.xlabel(\&quot;Number of Previous Cancellations\&quot;, size=15)\n&quot;, 
    &quot;plt.ylabel(\&quot;%\&quot;, size=15)\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; The percentages show that when there are more previous cancellations, there is\n&quot;, 
    &quot;&gt;&gt; a substantially higher chance the customer will cancel again.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Total of Special Requests&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# number of instances for each value\n&quot;, 
    &quot;df2[\&quot;total_of_special_requests\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# group by cancellations\n&quot;, 
    &quot;is_canceled = df2.groupby(by=\&quot;is_canceled\&quot;)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# get groups according to binary outcome\n&quot;, 
    &quot;canceled = is_canceled.get_group(1)\n&quot;, 
    &quot;not_canceled = is_canceled.get_group(0)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# count values for each outcome\n&quot;, 
    &quot;special_requests_0 = not_canceled[\&quot;total_of_special_requests\&quot;].value_counts()\n&quot;, 
    &quot;special_requests_1 = canceled[\&quot;total_of_special_requests\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# create a DataFrame for each outcome\n&quot;, 
    &quot;df_special_requests_0 = pd.DataFrame(special_requests_0.values, index=special_requests_0.index, columns=[\&quot;not_canceled\&quot;])\n&quot;, 
    &quot;df_special_requests_1 = pd.DataFrame(special_requests_1.values, index=special_requests_1.index, columns=[\&quot;canceled\&quot;])&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# join both DataFrames side by side\n&quot;, 
    &quot;df_special_requests= df_special_requests_0.join(df_special_requests_1)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# add total of both outcomes\n&quot;, 
    &quot;special_requests_total = df_special_requests[\&quot;not_canceled\&quot;] + df_special_requests[\&quot;canceled\&quot;]\n&quot;, 
    &quot;\n&quot;, 
    &quot;# calculate percentage of cancellations for each number of requests value individually\n&quot;, 
    &quot;special_requests_percentage = []\n&quot;, 
    &quot;for i in special_requests_total.index:\n&quot;, 
    &quot;    special_requests_percentage.append(round((special_requests_1[i]/special_requests_total[i])*100,2))\n&quot;, 
    &quot;special_requests_percentage&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# add percentages as new column in DataFrame\n&quot;, 
    &quot;df_special_requests.join(pd.DataFrame(special_requests_percentage, index=df_special_requests.index,\n&quot;, 
    &quot;             columns=[\&quot;cancellations %\&quot;]))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# plot special requests according to cancellations\n&quot;, 
    &quot;plt.figure(figsize=(10,5))\n&quot;, 
    &quot;sns.countplot(x=df2[\&quot;total_of_special_requests\&quot;], hue=df2[\&quot;is_canceled\&quot;])\n&quot;, 
    &quot;plt.title(\&quot;Special Requests\&quot;, size=20)\n&quot;, 
    &quot;plt.xlabel(\&quot;Number of Special Requests\&quot;, size=15)\n&quot;, 
    &quot;plt.legend([\&quot;not canceled\&quot;, \&quot;canceled\&quot;])\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; * Nearly half of the bookings without special requests are canceled.\n&quot;, 
    &quot;&gt;&gt; * There are fewer cancellations when the number of special requests increases.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Required Car Parking Spaces&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# number of instances for each value\n&quot;, 
    &quot;df2[\&quot;required_car_parking_spaces\&quot;].value_counts().sort_index()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# count values for each outcome with previous groupby\n&quot;, 
    &quot;parking_spaces_0 = not_canceled[\&quot;required_car_parking_spaces\&quot;].value_counts()\n&quot;, 
    &quot;parking_spaces_1 = canceled[\&quot;required_car_parking_spaces\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# value counts for non canceled instances\n&quot;, 
    &quot;parking_spaces_0.sort_index()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# value counts for canceled instances\n&quot;, 
    &quot;parking_spaces_1&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# pie plot of cancellations with zero required parking spaces\n&quot;, 
    &quot;plt.pie(x=[parking_spaces_0[0], parking_spaces_1[0]], labels=[\&quot;not_canceled\&quot;, \&quot;canceled\&quot;],autopct='%1.1f%%',\n&quot;, 
    &quot;        startangle=90, colors=['forestgreen', 'firebrick'])\n&quot;, 
    &quot;plt.title(\&quot;Zero Required Parking Spaces Cancellations\&quot;, size=20)\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; * Dividing the instances into groups according to cancellations shows that canceled\n&quot;, 
    &quot;&gt;&gt; bookings were only ones without required parking spaces.\n&quot;, 
    &quot;&gt;&gt; * This could potentially be a bad indication for cancellations. The model could learn\n&quot;, 
    &quot;&gt;&gt; that a booking can be canceled **only** if no parking spaces were required, which does not\n&quot;, 
    &quot;&gt;&gt; necessarily have to be the case.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Booking Changes&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# number of instances for each value\n&quot;, 
    &quot;df2[\&quot;booking_changes\&quot;].value_counts().sort_index()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# count values for each outcome with previous groupby\n&quot;, 
    &quot;booking_changes_0 = not_canceled[\&quot;booking_changes\&quot;].value_counts()\n&quot;, 
    &quot;booking_changes_1 = canceled[\&quot;booking_changes\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# count index of not canceled\n&quot;, 
    &quot;len(booking_changes_0.index)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# count index of canceled\n&quot;, 
    &quot;len(booking_changes_1.index)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# fill missing values\n&quot;, 
    &quot;# the outcome 0 has more values\n&quot;, 
    &quot;# filling the values will enable joining the dataframes later\n&quot;, 
    &quot;df_booking_changes_1 = pd.DataFrame(booking_changes_1, index=booking_changes_0.index)\n&quot;, 
    &quot;df_booking_changes_1.fillna({\&quot;booking_changes\&quot;: 0}, inplace=True)\n&quot;, 
    &quot;booking_changes_1 = pd.Series(df_booking_changes_1[\&quot;booking_changes\&quot;])&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# add total of both outcomes\n&quot;, 
    &quot;booking_changes_total = booking_changes_0 + booking_changes_1\n&quot;, 
    &quot;\n&quot;, 
    &quot;# calculate percentage of cancellations for each number of booking changes individually\n&quot;, 
    &quot;percentage_booking_changes = []\n&quot;, 
    &quot;for i in booking_changes_total.index:\n&quot;, 
    &quot;    percentage_booking_changes.append(round((booking_changes_1[i]/booking_changes_total[i])*100,2))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# create a DataFrame with the percentage of cancellations\n&quot;, 
    &quot;df_percentage_booking_changes = pd.DataFrame(percentage_booking_changes, index=booking_changes_total.index,\n&quot;, 
    &quot;                                             columns=[\&quot;cancellations %\&quot;])&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# create a DataFrame for each outcome\n&quot;, 
    &quot;df_booking_changes_0 = pd.DataFrame(booking_changes_0.values, index=booking_changes_0.index, columns=[\&quot;not_canceled\&quot;])\n&quot;, 
    &quot;df_booking_changes_1 = pd.DataFrame(booking_changes_1.values, index=booking_changes_1.index, columns=[\&quot;canceled\&quot;])&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# join all three DataFrames side by side\n&quot;, 
    &quot;df_booking_changes = df_booking_changes_0.join\\\n&quot;, 
    &quot;    ([df_booking_changes_1, df_percentage_booking_changes])\n&quot;, 
    &quot;\n&quot;, 
    &quot;# remove rows with 0% cancellations\n&quot;, 
    &quot;df_booking_changes = df_booking_changes[df_booking_changes[\&quot;cancellations %\&quot;]!=0]\n&quot;, 
    &quot;df_booking_changes&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; * While a large amount of bookings with no changes were canceled, this category can change overtime\n&quot;, 
    &quot;&gt;&gt; which could possibly be a source of leakage.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Understanding the ADR Feature\n&quot;, 
    &quot;&gt;&gt; Since this feature is not entirely clear from the description on Kaggle,\n&quot;, 
    &quot;&gt;&gt; I've decided to further assess it.\n&quot;, 
    &quot;&gt;&gt;\n&quot;, 
    &quot;&gt;&gt; The Average Daily Rate (ADR) is typically calculated by taking the average revenue\n&quot;, 
    &quot;&gt;&gt; earned from the rooms and dividing by the number of rooms sold (excluding rooms occupied\n&quot;, 
    &quot;&gt;&gt; by staff).\n&quot;, 
    &quot;&gt;&gt;\n&quot;, 
    &quot;&gt;&gt; Since it is not clear if an ADR of zero indicates that the booking was canceled or\n&quot;, 
    &quot;&gt;&gt; if the hotel did not gain profit, I will look at instances listed with an ADR\n&quot;, 
    &quot;&gt;&gt; of zero. This should provide enough insight to see if this feature should be removed\n&quot;, 
    &quot;&gt;&gt; during before model evaluations.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2[df2[\&quot;adr\&quot;]==0][\&quot;reservation_status\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2[df2[\&quot;adr\&quot;]==0][\&quot;is_canceled\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; * Most bookings are labeled as checked-out and not canceled when the ADR was zero.\n&quot;, 
    &quot;&gt;&gt; This concludes the previous speculation.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Categorical Attributes:&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Hotels and Arrival Month&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2[\&quot;hotel\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# a plot of the number of instances for each hotel according to cancellations\n&quot;, 
    &quot;plt.figure(figsize=(10,5))\n&quot;, 
    &quot;sns.countplot(x=df2[\&quot;hotel\&quot;], hue=df2[\&quot;is_canceled\&quot;])\n&quot;, 
    &quot;plt.title(\&quot;Hotel Cancellations\&quot;, size=20)\n&quot;, 
    &quot;plt.legend([\&quot;not canceled\&quot;, \&quot;canceled\&quot;])\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;ordered_months = [\&quot;January\&quot;, \&quot;February\&quot;, \&quot;March\&quot;, \&quot;April\&quot;, \&quot;May\&quot;, \&quot;June\&quot;,\n&quot;, 
    &quot;          \&quot;July\&quot;, \&quot;August\&quot;, \&quot;September\&quot;, \&quot;October\&quot;, \&quot;November\&quot;, \&quot;December\&quot;]\n&quot;, 
    &quot;\n&quot;, 
    &quot;resort_canceled_percent = []\n&quot;, 
    &quot;city_canceled_percent = []\n&quot;, 
    &quot;\n&quot;, 
    &quot;# divide cancellation outcome by hotel and month of arrival\n&quot;, 
    &quot;resort_1 = canceled[canceled[\&quot;hotel\&quot;]==\&quot;Resort Hotel\&quot;][\&quot;arrival_date_month\&quot;].value_counts()\n&quot;, 
    &quot;resort_0 = not_canceled[not_canceled[\&quot;hotel\&quot;]==\&quot;Resort Hotel\&quot;][\&quot;arrival_date_month\&quot;].value_counts()\n&quot;, 
    &quot;city_1 = canceled[canceled[\&quot;hotel\&quot;]==\&quot;City Hotel\&quot;][\&quot;arrival_date_month\&quot;].value_counts()\n&quot;, 
    &quot;city_0 = not_canceled[not_canceled[\&quot;hotel\&quot;]==\&quot;City Hotel\&quot;][\&quot;arrival_date_month\&quot;].value_counts()\n&quot;, 
    &quot;\n&quot;, 
    &quot;# calculate cancellation percentage according to hotel\n&quot;, 
    &quot;for i in ordered_months:\n&quot;, 
    &quot;    resort_canceled_percent.append(round((resort_1[i] / (resort_0[i]+resort_1[i]))*100,2))\n&quot;, 
    &quot;    city_canceled_percent.append(round((city_1[i]/(city_0[i]+city_1[i]))*100,2))\n&quot;, 
    &quot;\n&quot;, 
    &quot;# create a DataFrame with the cancellation percentage of each hotel\n&quot;, 
    &quot;df_resort_cancel = pd.DataFrame(resort_canceled_percent, index=ordered_months, columns=[\&quot;Resort Hotel Canceled %\&quot;])\n&quot;, 
    &quot;df_city_cancel = pd.DataFrame(city_canceled_percent, index=ordered_months, columns=[\&quot;City Hotel Canceled %\&quot;])\n&quot;, 
    &quot;\n&quot;, 
    &quot;# join DataFrames\n&quot;, 
    &quot;df_hotel_cancel = df_resort_cancel.join(df_city_cancel)\n&quot;, 
    &quot;df_hotel_cancel&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; * There are more instances for City Hotel than Resort Hotel in the data.\n&quot;, 
    &quot;&gt;&gt; * City Hotel has a higher cancellation rate according to arrival months.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Meal Booked&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# plot meal according to cancellations\n&quot;, 
    &quot;plt.figure(figsize=(10,5))\n&quot;, 
    &quot;sns.countplot(x=df2[\&quot;meal\&quot;], hue=df2[\&quot;is_canceled\&quot;])\n&quot;, 
    &quot;plt.title(\&quot;Cancellations According to Meal Booked\&quot;, size=20)\n&quot;, 
    &quot;plt.xlabel(\&quot;meal\&quot;, size=15)\n&quot;, 
    &quot;plt.legend([\&quot;not canceled\&quot;, \&quot;canceled\&quot;])\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; * The BB (Bed &amp; Breakfast) meal is most common. It is also most frequently canceled.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Market Segment, Distribution Channel, Customer Type and Room Type&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2[\&quot;market_segment\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# calculate cancellation percentage according to market segment\n&quot;, 
    &quot;market_segment_percent = []\n&quot;, 
    &quot;\n&quot;, 
    &quot;market_segment_1 = canceled[\&quot;market_segment\&quot;].value_counts()\n&quot;, 
    &quot;market_segment_total = df2[\&quot;market_segment\&quot;].value_counts()\n&quot;, 
    &quot;\n&quot;, 
    &quot;for i in market_segment_total.index:\n&quot;, 
    &quot;    market_segment_percent.append(str(i+\&quot;: \&quot;) +\n&quot;, 
    &quot;                    str(round((market_segment_1[i]/market_segment_total[i])*100,2)))\n&quot;, 
    &quot;market_segment_percent&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2[\&quot;distribution_channel\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# calculate cancellation percentage according to distribution channel\n&quot;, 
    &quot;distribution_channel_percent = []\n&quot;, 
    &quot;\n&quot;, 
    &quot;distribution_channel_1 = canceled[\&quot;distribution_channel\&quot;].value_counts()\n&quot;, 
    &quot;distribution_channel_total = df2[\&quot;distribution_channel\&quot;].value_counts()\n&quot;, 
    &quot;\n&quot;, 
    &quot;for i in distribution_channel_total.index:\n&quot;, 
    &quot;    distribution_channel_percent.append(str(i+\&quot;: \&quot;) +\n&quot;, 
    &quot;                    str(round((distribution_channel_1[i]/distribution_channel_total[i])*100,2)))\n&quot;, 
    &quot;distribution_channel_percent&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2[\&quot;customer_type\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# calculate cancellation percentage according to customer type\n&quot;, 
    &quot;customer_type_percent = []\n&quot;, 
    &quot;\n&quot;, 
    &quot;customer_type_1 = canceled[\&quot;customer_type\&quot;].value_counts()\n&quot;, 
    &quot;customer_type_total = df2[\&quot;customer_type\&quot;].value_counts()\n&quot;, 
    &quot;\n&quot;, 
    &quot;for i in customer_type_total.index:\n&quot;, 
    &quot;    customer_type_percent.append(str(i+\&quot;: \&quot;) +\n&quot;, 
    &quot;                    str(round((customer_type_1[i]/customer_type_total[i])*100,2)))\n&quot;, 
    &quot;customer_type_percent&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# plot of cancellations according to room type\n&quot;, 
    &quot;plt.figure(figsize=(10,5))\n&quot;, 
    &quot;sns.countplot(x=df2[\&quot;reserved_room_type\&quot;], hue=df2[\&quot;is_canceled\&quot;])\n&quot;, 
    &quot;plt.title(\&quot;Cancellations According to Room Type\&quot;, size=20)\n&quot;, 
    &quot;plt.legend([\&quot;not canceled\&quot;, \&quot;canceled\&quot;], loc=1)\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; * Market segment cancellation rates are highest amongst travel agencies and tour operators.\n&quot;, 
    &quot;&gt;&gt; * Distribution channel cancellation rates are highest amongst groups, travel agencies and tour operators.\n&quot;, 
    &quot;&gt;&gt; * Customer type cancellation rates are highest amongst transient\n&quot;, 
    &quot;&gt;&gt; (meaning the booking is not part of a group or contract and is not associated to another transient booking).\n&quot;, 
    &quot;&gt;&gt; * The room type \&quot;A\&quot; is canceled most frequently.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Deposit Type&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2[\&quot;deposit_type\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# calculate deposit type instances percentage in data\n&quot;, 
    &quot;deposit_percent = round(df2[\&quot;deposit_type\&quot;].value_counts()/len(df[\&quot;deposit_type\&quot;])*100,4)\n&quot;, 
    &quot;deposit_percent&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# use groupby to divide according to deposit type\n&quot;, 
    &quot;deposit = df2.groupby(by=\&quot;deposit_type\&quot;)\n&quot;, 
    &quot;non_refund = deposit.get_group(\&quot;Non Refund\&quot;)\n&quot;, 
    &quot;refundable = deposit.get_group(\&quot;Refundable\&quot;)\n&quot;, 
    &quot;no_deposit = deposit.get_group(\&quot;No Deposit\&quot;)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# calculate number of cancellations according to deposit type\n&quot;, 
    &quot;no_deposit_0 = (no_deposit[\&quot;is_canceled\&quot;]==0).sum()\n&quot;, 
    &quot;no_deposit_1 = (no_deposit[\&quot;is_canceled\&quot;]==1).sum()\n&quot;, 
    &quot;non_refund_0 = (non_refund[\&quot;is_canceled\&quot;]==0).sum()\n&quot;, 
    &quot;non_refund_1 = (non_refund[\&quot;is_canceled\&quot;]==1).sum()\n&quot;, 
    &quot;refundable_0 = (refundable[\&quot;is_canceled\&quot;]==0).sum()\n&quot;, 
    &quot;refundable_1 = (refundable[\&quot;is_canceled\&quot;]==1).sum()\n&quot;, 
    &quot;all_canceled = no_deposit_1 + non_refund_1 + refundable_1\n&quot;, 
    &quot;all_not_canceled = no_deposit_0 + non_refund_0 + refundable_0&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# check that all values were calculated\n&quot;, 
    &quot;all_canceled + all_not_canceled == df2[\&quot;deposit_type\&quot;].size&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# create a DataFrame with the number of instances for each deposit type\n&quot;, 
    &quot;df_deposit_type = pd.DataFrame(index=[\&quot;Not Canceled\&quot;, \&quot;Canceled\&quot;])\n&quot;, 
    &quot;df_deposit_type[\&quot;no_deposit\&quot;] = [no_deposit_0, no_deposit_1]\n&quot;, 
    &quot;df_deposit_type[\&quot;non_refund\&quot;] = [non_refund_0, non_refund_1]\n&quot;, 
    &quot;df_deposit_type[\&quot;refundable\&quot;] = [refundable_0, refundable_1]\n&quot;, 
    &quot;df_deposit_type&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# pie plot of cancellations according to deposit type\n&quot;, 
    &quot;cancel_labels = [\&quot;cancelled\&quot;, \&quot;not_cancelled\&quot;]\n&quot;, 
    &quot;fig, dx = plt.subplots(1,3, figsize=(21,6))\n&quot;, 
    &quot;dx[0].pie(np.array([no_deposit_1, no_deposit_0]), labels=cancel_labels, autopct='%1.1f%%', startangle=90,\n&quot;, 
    &quot;          colors=['firebrick', 'forestgreen'])\n&quot;, 
    &quot;dx[0].set_title(\&quot;No Deposit Cancellations\&quot;, size=20)\n&quot;, 
    &quot;dx[1].pie(np.array([non_refund_1, non_refund_0]), labels=cancel_labels, autopct='%1.1f%%', startangle=90,\n&quot;, 
    &quot;          colors=['firebrick', 'forestgreen'])\n&quot;, 
    &quot;dx[1].set_title(\&quot;Non Refund Cancellations\&quot;, size=20)\n&quot;, 
    &quot;dx[2].pie(np.array([refundable_1, refundable_0]), labels=cancel_labels, autopct='%1.1f%%', startangle=90,\n&quot;, 
    &quot;          colors=['firebrick', 'forestgreen'])\n&quot;, 
    &quot;dx[2].set_title(\&quot;Refundable Cancellations\&quot;, size=20)\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; #### Observations:\n&quot;, 
    &quot;&gt;&gt; * The non refund values and graph look a bit off. It almost seems that the values\n&quot;, 
    &quot;&gt;&gt; for canceled and not canceled were accidentally switched!\n&quot;, 
    &quot;&gt;&gt; In light of this, it might be better to evaluate the model both with and without this\n&quot;, 
    &quot;&gt;&gt; feature.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Cancellations According to Country of Origin&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df2[\&quot;country\&quot;].unique().size&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;canceled[\&quot;country\&quot;].value_counts()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# calculate countries by number of instances that appear in data\n&quot;, 
    &quot;country_1 = (df2[\&quot;country\&quot;].value_counts() &lt;= 1).sum()\n&quot;, 
    &quot;country_10 = (df2[\&quot;country\&quot;].value_counts() &lt;= 10).sum()\n&quot;, 
    &quot;country_50 = (df2[\&quot;country\&quot;].value_counts() &lt;= 50).sum()\n&quot;, 
    &quot;country_100 = (df2[\&quot;country\&quot;].value_counts() &lt;= 100).sum()\n&quot;, 
    &quot;country_1000 = (df2[\&quot;country\&quot;].value_counts() &lt;= 1000).sum()\n&quot;, 
    &quot;\n&quot;, 
    &quot;print(\&quot;Number of countries with one or less instances:\&quot;, country_1,\n&quot;, 
    &quot;      \&quot;\\nNumber of countries with 10 or less instances:\&quot;, country_10,\n&quot;, 
    &quot;      \&quot;\\nNumber of countries with 50 or less instances:\&quot;, country_50,\n&quot;, 
    &quot;      \&quot;\\nNumber of countries with 100 or less instances:\&quot;, country_100,\n&quot;, 
    &quot;      \&quot;\\nNumber of countries with 1000 or less instances:\&quot;, country_1000)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Observations:\n&quot;, 
    &quot;&gt;&gt; * There are 175 unique countries. This indicates that the data is representative\n&quot;, 
    &quot;&gt;&gt; worldwide, contrary to a specific region.\n&quot;, 
    &quot;&gt;&gt; * More than half of the instances have 50 or fewer observations in the DataFrame.\n&quot;, 
    &quot;&gt;&gt; * A model would likely generalize better if we avoid using this column.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 3. Data Cleaning&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# clean copy of the training set\n&quot;, 
    &quot;df3 = train_set.copy()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# custom transformer removes instances with zero guests\n&quot;, 
    &quot;\n&quot;, 
    &quot;class RemoveZeroGuests(TransformerMixin):\n&quot;, 
    &quot;\n&quot;, 
    &quot;    def fit(self, X, y=None):\n&quot;, 
    &quot;        return self\n&quot;, 
    &quot;\n&quot;, 
    &quot;    def transform(self, X):\n&quot;, 
    &quot;        XData = X.loc[((X[\&quot;adults\&quot;]) + (X[\&quot;children\&quot;]) + (X[\&quot;babies\&quot;])) &gt; 0]\n&quot;, 
    &quot;        return XData&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df3.shape&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# use transformer to remove instances with zero guests stayed\n&quot;, 
    &quot;df3 = RemoveZeroGuests().fit_transform(df3)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;df3.shape&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# separate predictors from target values\n&quot;, 
    &quot;\n&quot;, 
    &quot;# drop- creates a copy without changing the training set\n&quot;, 
    &quot;X_train = df3.drop(\&quot;is_canceled\&quot;, axis=1)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# create a deep copy of the target values\n&quot;, 
    &quot;y_train = df3[\&quot;is_canceled\&quot;].copy()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Removing the Following Columns:\n&quot;, 
    &quot;&gt;&gt; #### Numerical Attributes:\n&quot;, 
    &quot;&gt;&gt; * arrival_date_year: This category references towards certain years. This could be\n&quot;, 
    &quot;&gt;&gt; problematic for instances during years that do not appear in the training data, or\n&quot;, 
    &quot;&gt;&gt; perhaps have bias towards certain years specifically due to the unequal amounts of\n&quot;, 
    &quot;&gt;&gt; observations in the training data.\n&quot;, 
    &quot;&gt;&gt; * arrival_date_day_of_month: The column arrival date week of month generalizes this.\n&quot;, 
    &quot;&gt;&gt; * booking_changes: Could change over time, potentially causing data leakage.\n&quot;, 
    &quot;&gt;&gt; * days_in_waiting_list: Could constantly change over time. Additionally, there are many\n&quot;, 
    &quot;&gt;&gt; instances. This could prevent the model from generalizing.\n&quot;, 
    &quot;&gt;&gt; * agent &amp; company: Represented by an ID. These columns are uninformative since they\n&quot;, 
    &quot;&gt;&gt; contain a substantial amount of various numerical values without having an actual\n&quot;, 
    &quot;&gt;&gt; numerical meaning. Since other columns (such as market segment) indicate the type of\n&quot;, 
    &quot;&gt;&gt; reservation, these columns won't be needed.\n&quot;, 
    &quot;&gt;&gt;\n&quot;, 
    &quot;&gt;&gt; #### Categorical Attributes:\n&quot;, 
    &quot;&gt;&gt; * country: There are many categories, most with few instances. In order to make a model\n&quot;, 
    &quot;&gt;&gt; that generalizes, it is better to dismiss this category.\n&quot;, 
    &quot;&gt;&gt; * assigned_room_type: Similar to reserved_room_type and seems like the reserved room is\n&quot;, 
    &quot;&gt;&gt; a more suitable choice.\n&quot;, 
    &quot;&gt;&gt; * reservation_status: Major data leakage! The categories are Check-Out, Canceled and No-Show.\n&quot;, 
    &quot;&gt;&gt; This is exactly what we are trying to predict.\n&quot;, 
    &quot;&gt;&gt; * reservation_status_date: This is the date when the reservation status was last changed,\n&quot;, 
    &quot;&gt;&gt; and therefore is irrelevant.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;num_features = [\&quot;lead_time\&quot;, \&quot;stays_in_weekend_nights\&quot;, \&quot;stays_in_week_nights\&quot;, \&quot;adults\&quot;, \&quot;children\&quot;, \&quot;babies\&quot;,\n&quot;, 
    &quot;                \&quot;is_repeated_guest\&quot;, \&quot;previous_cancellations\&quot;, \&quot;previous_bookings_not_canceled\&quot;, \&quot;adr\&quot;,\n&quot;, 
    &quot;                \&quot;required_car_parking_spaces\&quot;, \&quot;total_of_special_requests\&quot;]\n&quot;, 
    &quot;\n&quot;, 
    &quot;cat_features = [\&quot;hotel\&quot;, \&quot;arrival_date_month\&quot;, \&quot;arrival_date_week_number\&quot;, \&quot;meal\&quot;, \&quot;market_segment\&quot;,\n&quot;, 
    &quot;                \&quot;distribution_channel\&quot;, \&quot;reserved_room_type\&quot;, \&quot;deposit_type\&quot;, \&quot;customer_type\&quot;]&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# Undefined/SC both represent no meal package and can be combined\n&quot;, 
    &quot;\n&quot;, 
    &quot;class ReplaceMeal(TransformerMixin):\n&quot;, 
    &quot;\n&quot;, 
    &quot;    def fit(self,X, y=None):\n&quot;, 
    &quot;        return self\n&quot;, 
    &quot;\n&quot;, 
    &quot;    def transform(self, X):\n&quot;, 
    &quot;        XData = X.copy()\n&quot;, 
    &quot;        XData[\&quot;meal\&quot;].replace(\&quot;Undefined\&quot;, \&quot;SC\&quot;, inplace=True)\n&quot;, 
    &quot;        return XData&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# SimpleImputer constant default fills values with zero\n&quot;, 
    &quot;# MinMaxScaler normalizes data (rescales between 0-1)\n&quot;, 
    &quot;num_pipeline = Pipeline([\n&quot;, 
    &quot;    (\&quot;imputer\&quot;, SimpleImputer(strategy=\&quot;constant\&quot;)),\n&quot;, 
    &quot;    (\&quot;min_max\&quot;, MinMaxScaler())\n&quot;, 
    &quot;])&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# SimpleImputer fills missing values with 'Unknown'\n&quot;, 
    &quot;# OneHotEncoder converts categories to a numeric dummy array\n&quot;, 
    &quot;# (one binary attribute per category)\n&quot;, 
    &quot;cat_pipeline = Pipeline([\n&quot;, 
    &quot;    (\&quot;meal\&quot;, ReplaceMeal()),\n&quot;, 
    &quot;    (\&quot;imputer\&quot;, SimpleImputer(strategy=\&quot;constant\&quot;, fill_value=\&quot;Unknown\&quot;)),\n&quot;, 
    &quot;    (\&quot;one_hot\&quot;, OneHotEncoder(handle_unknown=\&quot;ignore\&quot;))\n&quot;, 
    &quot;])&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# column transformer:\n&quot;, 
    &quot;# features generated by each transformer will be concatenated to form a single feature space\n&quot;, 
    &quot;# columns of the original feature matrix that are not specified are dropped\n&quot;, 
    &quot;full_pipeline = ColumnTransformer([\n&quot;, 
    &quot;    (\&quot;numerical\&quot;, num_pipeline, num_features),\n&quot;, 
    &quot;    (\&quot;categorical\&quot;, cat_pipeline, cat_features)\n&quot;, 
    &quot;])&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# transform training data using pipeline\n&quot;, 
    &quot;X_train_prepared = full_pipeline.fit_transform(X_train)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# transform training data without fit for testing\n&quot;, 
    &quot;X_tr_testing = full_pipeline.transform(X_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 4. Training and Evaluating Models&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; Accuracy is less relevant for an imbalanced classification problem.\n&quot;, 
    &quot;&gt; Evaluating by a metric that represents the data better is important.\n&quot;, 
    &quot;&gt;\n&quot;, 
    &quot;&gt; Chosen evaluation metric:\n&quot;, 
    &quot;&gt;\n&quot;, 
    &quot;&gt; The F1 Score is calculated by using precision (the accuracy of the positive predictions) and\n&quot;, 
    &quot;&gt; recall (the ratio of positive instances correctly classified) accuracy.\n&quot;, 
    &quot;&gt; This metric gives a higher value towards false positives rather than false negatives.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# function prints scores\n&quot;, 
    &quot;def display_evaluation(actual, pred):\n&quot;, 
    &quot;    print(\&quot;Confusion Matrix:\\n\&quot;, metrics.confusion_matrix(actual, pred), \&quot;\\n\&quot;)\n&quot;, 
    &quot;    print(\&quot;Classification Report:\\n\&quot;, metrics.classification_report(actual, pred))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Model 1: KNN&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# instantiate classifier\n&quot;, 
    &quot;# default k=5\n&quot;, 
    &quot;knn = KNeighborsClassifier()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# fit the training set\n&quot;, 
    &quot;knn.fit(X_train_prepared, y_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# test on a few instances from training data\n&quot;, 
    &quot;some_data = X_train.iloc[:10]\n&quot;, 
    &quot;some_labels = y_train.iloc[:10]\n&quot;, 
    &quot;some_data_prepared = full_pipeline.transform(some_data)\n&quot;, 
    &quot;print(\&quot;Predictions:\&quot;, knn.predict(some_data_prepared))\n&quot;, 
    &quot;print(\&quot;Labels:\&quot;, list(some_labels))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# predict using the training data\n&quot;, 
    &quot;knn_pred = knn.predict(X_tr_testing)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# use function to show results\n&quot;, 
    &quot;display_evaluation(y_train, knn_pred)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Model 2: KNN&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# instantiate KNN model using distance instead of uniform\n&quot;, 
    &quot;# distance means closer instances have a larger weight\n&quot;, 
    &quot;# uniform weighs all instances equally\n&quot;, 
    &quot;# default k=5\n&quot;, 
    &quot;knn = KNeighborsClassifier(weights=\&quot;distance\&quot;)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# fit the training set\n&quot;, 
    &quot;knn.fit(X_train_prepared, y_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# test on a few instances from training data\n&quot;, 
    &quot;some_data = X_train.iloc[:10]\n&quot;, 
    &quot;some_labels = y_train.iloc[:10]\n&quot;, 
    &quot;some_data_prepared = full_pipeline.transform(some_data)\n&quot;, 
    &quot;print(\&quot;Predictions:\&quot;, knn.predict(some_data_prepared))\n&quot;, 
    &quot;print(\&quot;Labels:\&quot;, list(some_labels))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# predict using the training data\n&quot;, 
    &quot;knn_pred_2 = knn.predict(X_tr_testing)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# use function to show results\n&quot;, 
    &quot;display_evaluation(y_train, knn_pred_2)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; So far, the performance of the KNN model using distance weights instead of uniform\n&quot;, 
    &quot;&gt; drastically improved the results.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Model 3: Random Forest Classifier&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### What is the Random Forest Classification Model?\n&quot;, 
    &quot;\n&quot;, 
    &quot;Forests are based on multiple decision trees, so it is vital to first understand how decision\n&quot;, 
    &quot;trees work.\n&quot;, 
    &quot;\n&quot;, 
    &quot;A decision tree is a non-linear model built by constructing many linear boundaries.\n&quot;, 
    &quot;The tree works as a sequence of yes or no, true or false questions that progress down\n&quot;, 
    &quot;the tree until reaching a predicted class. The data is split into nodes based on\n&quot;, 
    &quot;feature values. This model is good for occasions when there is no single linear line that\n&quot;, 
    &quot;can divide the data. Gini Impurity of a node represents the probability that a randomly chosen\n&quot;, 
    &quot;sample would be incorrectly classified, so the goal is to reduce this as much as possible.\n&quot;, 
    &quot;\n&quot;, 
    &quot;Using a single decision tree could cause overfitting of the training data. For example,\n&quot;, 
    &quot;a decision tree could create a leaf node (the predicted class) for each instance.\n&quot;, 
    &quot;Using a forest could help generalize better to new data. The random forest model\n&quot;, 
    &quot;samples random points and subsets of features when training. Then, the predictions are made\n&quot;, 
    &quot;by averaging the predictions made by each decision tree.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# max features default is sqrt (number of features selected per split)\n&quot;, 
    &quot;# bootstrap default is true (resampling data true)\n&quot;, 
    &quot;# n estimators default is 100 (number of decision tree classifiers)\n&quot;, 
    &quot;rf_clf = RandomForestClassifier(random_state=42, n_jobs=-1)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# fit the training set\n&quot;, 
    &quot;rf_clf.fit(X_train_prepared, y_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# test on a few instances from training data\n&quot;, 
    &quot;some_data = X_train.iloc[:10]\n&quot;, 
    &quot;some_labels = y_train.iloc[:10]\n&quot;, 
    &quot;some_data_prepared = full_pipeline.transform(some_data)\n&quot;, 
    &quot;print(\&quot;Predictions:\&quot;, rf_clf.predict(some_data_prepared))\n&quot;, 
    &quot;print(\&quot;Labels:\&quot;, list(some_labels))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# predict using the training data\n&quot;, 
    &quot;rf_pred = rf_clf.predict(X_tr_testing)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# use function to show results\n&quot;, 
    &quot;print(display_evaluation(y_train, rf_pred))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; The Random Forest Classification model performed slightly better than the second\n&quot;, 
    &quot;&gt; KNN model. The next step is to find the hyperparameters\n&quot;, 
    &quot;&gt; that provide the best results.\n&quot;, 
    &quot;&gt;\n&quot;, 
    &quot;&gt; Since the dataset is rather large, and it would take a long time\n&quot;, 
    &quot;&gt; to run all estimators, using randomized search cv is the ideal\n&quot;, 
    &quot;&gt; option. The size of the dataset is also the reason I have neglected\n&quot;, 
    &quot;&gt; randomized search for the KNN model.\n&quot;, 
    &quot;&gt;\n&quot;, 
    &quot;&gt; The randomized search runs an amount of iterations specified\n&quot;, 
    &quot;&gt; and tries random combinations of the attributes listed.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Random Search Cross Validation 1&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# parameters for random search\n&quot;, 
    &quot;param_dist_rf = [{\&quot;n_estimators\&quot;: [10, 50, 100, 500], \&quot;max_features\&quot;: [\&quot;sqrt\&quot;, 8, 16], \&quot;bootstrap\&quot;: [True, False]}]&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# instantiate randomized search\n&quot;, 
    &quot;rf_cv = RandomizedSearchCV(rf_clf, param_dist_rf, n_iter=10, random_state=42, cv=5, scoring=\&quot;f1\&quot;)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# fit the training set\n&quot;, 
    &quot;rf_cv.fit(X_train_prepared, y_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# show the best score\n&quot;, 
    &quot;rf_cv.best_score_&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# show the best estimator parameters\n&quot;, 
    &quot;rf_clf = rf_cv.best_estimator_\n&quot;, 
    &quot;rf_clf&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# show results for each iteration\n&quot;, 
    &quot;cvres = rf_cv.cv_results_\n&quot;, 
    &quot;for mean_score, params in zip(cvres[\&quot;mean_test_score\&quot;], cvres[\&quot;params\&quot;]):\n&quot;, 
    &quot;    print(mean_score, params)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Model 4: Random Forest Classifier&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# predict using training data\n&quot;, 
    &quot;rf_pred_2 = rf_clf.predict(X_tr_testing)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# display evaluation scores\n&quot;, 
    &quot;display_evaluation(y_train, rf_pred_2)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Feature Importance&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# pair the feature names with the results from randomized search\n&quot;, 
    &quot;feature_importance = rf_cv.best_estimator_.feature_importances_\n&quot;, 
    &quot;features = num_features+cat_features\n&quot;, 
    &quot;sorted(zip(feature_importance,features), reverse=True)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; Deposit type is pretty high on the list which raises speculation. As seen earlier,\n&quot;, 
    &quot;&gt; the cancellation rate was nearly 100% in the category Non Refund.\n&quot;, 
    &quot;&gt; Lets train a model without this feature.\n&quot;, 
    &quot;&gt;\n&quot;, 
    &quot;&gt; Additionally, lets train a model without the parameters that have less\n&quot;, 
    &quot;&gt; than 0.005 feature importance. If the training error is nearly the\n&quot;, 
    &quot;&gt; same when using fewer features, it might be more efficient to\n&quot;, 
    &quot;&gt; train a model without them.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# features left\n&quot;, 
    &quot;\n&quot;, 
    &quot;num_features_2 = [\&quot;lead_time\&quot;, \&quot;stays_in_weekend_nights\&quot;, \&quot;stays_in_week_nights\&quot;, \&quot;adults\&quot;, \&quot;children\&quot;,\n&quot;, 
    &quot;                  \&quot;previous_cancellations\&quot;, \&quot;adr\&quot;, \&quot;required_car_parking_spaces\&quot;, \&quot;total_of_special_requests\&quot;]\n&quot;, 
    &quot;\n&quot;, 
    &quot;cat_features_2 = [\&quot;hotel\&quot;, \&quot;arrival_date_month\&quot;]\n&quot;, 
    &quot;\n&quot;, 
    &quot;\n&quot;, 
    &quot;# category pipeline without meal transformer\n&quot;, 
    &quot;cat_pipeline_2 = Pipeline([\n&quot;, 
    &quot;    (\&quot;imputer\&quot;, SimpleImputer(strategy=\&quot;constant\&quot;, fill_value=\&quot;Unknown\&quot;)),\n&quot;, 
    &quot;    (\&quot;one_hot\&quot;, OneHotEncoder(handle_unknown=\&quot;ignore\&quot;))\n&quot;, 
    &quot;])\n&quot;, 
    &quot;\n&quot;, 
    &quot;# pipeline with new features\n&quot;, 
    &quot;full_pipeline_2 = ColumnTransformer([\n&quot;, 
    &quot;    (\&quot;numerical\&quot;, num_pipeline, num_features_2),\n&quot;, 
    &quot;    (\&quot;categorical\&quot;, cat_pipeline_2, cat_features_2)\n&quot;, 
    &quot;])&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# transform data with new pipeline\n&quot;, 
    &quot;X_train_prepared_2 = full_pipeline_2.fit_transform(X_train)\n&quot;, 
    &quot;X_tr_testing_2 = full_pipeline_2.transform(X_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Model 5: Random Forest Classifier&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# instantiate model\n&quot;, 
    &quot;rf_clf_2 = RandomForestClassifier(random_state=42, n_jobs=-1)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# fit the training set\n&quot;, 
    &quot;rf_clf_2.fit(X_train_prepared_2, y_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# predictions on training data\n&quot;, 
    &quot;rf_pred_3 = rf_clf_2.predict(X_tr_testing_2)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# display evaluation scores\n&quot;, 
    &quot;display_evaluation(y_train, rf_pred_3)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Random Search Cross Validation 2&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# parameters for random search\n&quot;, 
    &quot;param_dist = [{\&quot;n_estimators\&quot;: [10, 50, 100, 500], \&quot;max_features\&quot;: [4, 8, 16], \&quot;bootstrap\&quot;: [True, False]}]&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# instantiate randomized search\n&quot;, 
    &quot;rf_cv_2 = RandomizedSearchCV(rf_clf_2, param_dist, cv=5, n_iter=10, scoring=\&quot;f1\&quot;, random_state=42)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# fit the training set\n&quot;, 
    &quot;rf_cv_2.fit(X_train_prepared_2, y_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# show the best score\n&quot;, 
    &quot;rf_cv_2.best_score_&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# show the best estimator parameters\n&quot;, 
    &quot;rf_clf_3 = rf_cv_2.best_estimator_\n&quot;, 
    &quot;rf_clf_3&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# show results for each iteration\n&quot;, 
    &quot;cvres = rf_cv_2.cv_results_\n&quot;, 
    &quot;for mean_score, params in zip(cvres[\&quot;mean_test_score\&quot;], cvres[\&quot;params\&quot;]):\n&quot;, 
    &quot;    print(mean_score, params)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# predict using training data\n&quot;, 
    &quot;rf_pred_4 = rf_clf_3.predict(X_tr_testing_2)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# display evaluation scores\n&quot;, 
    &quot;display_evaluation(y_train, rf_pred_4)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;#### Dummy Classifier\n&quot;, 
    &quot;&gt; The dummy classifier serves as an indication and comparison for model performance.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# dummy classifier\n&quot;, 
    &quot;# classifies every instance as not canceled\n&quot;, 
    &quot;# BaseEstimator allows to set and get estimator parameters\n&quot;, 
    &quot;class NeverCanceledClassifier(BaseEstimator):\n&quot;, 
    &quot;\n&quot;, 
    &quot;    def fit(self, X, y=None):\n&quot;, 
    &quot;        pass\n&quot;, 
    &quot;\n&quot;, 
    &quot;    def predict(self, X):\n&quot;, 
    &quot;        return np.zeros((len(X), 1), dtype=int)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# instantiate dummy classifier\n&quot;, 
    &quot;never_canceled = NeverCanceledClassifier()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# fit the training set\n&quot;, 
    &quot;never_canceled.fit(X_train, y_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# predict using dummy classifier\n&quot;, 
    &quot;never_canceled_pred = never_canceled.predict(X_train)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# evaluate scores for comparison\n&quot;, 
    &quot;# can't assess using F1 score\n&quot;, 
    &quot;# precision will divide by zero\n&quot;, 
    &quot;print(\&quot;Accuracy:\&quot;, metrics.accuracy_score(y_train, never_canceled_pred))\n&quot;, 
    &quot;print(\&quot;Confusion Matrix:\\n\&quot;, metrics.confusion_matrix(y_train, never_canceled_pred))&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; ### Overview:\n&quot;, 
    &quot;&gt;&gt; ####  Removing nearly half of the features did not drastically change the score.\n&quot;, 
    &quot;&gt;&gt; * The model prior to feature selection had an F1 score of 0.99.\n&quot;, 
    &quot;&gt;&gt; * The model after feature selection has an F1 score of 0.98.\n&quot;, 
    &quot;&gt;&gt; * The model performs better than the dummy classifier.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# use predictions to get precision recall curve values\n&quot;, 
    &quot;rf_scores = rf_cv_2.best_estimator_.predict_proba(X_tr_testing_2)[:, 1]\n&quot;, 
    &quot;precisions, recalls, thresholds = metrics.precision_recall_curve(y_train, rf_scores)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# plot precision recall curve\n&quot;, 
    &quot;plt.figure(figsize=(10,5))\n&quot;, 
    &quot;plt.plot(precisions, recalls, linewidth=3)\n&quot;, 
    &quot;plt.title(\&quot;Precision Recall Curve for Hotel Cancellations\&quot;, size=20)\n&quot;, 
    &quot;plt.xlabel(\&quot;Recall\&quot;, size=15)\n&quot;, 
    &quot;plt.ylabel(\&quot;Precision\&quot;, size=15)\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;# 5. Evaluating the Test Set&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# separate test set predictors and labels\n&quot;, 
    &quot;X_test = test_set.drop(\&quot;is_canceled\&quot;, axis=1)\n&quot;, 
    &quot;y_test = test_set[\&quot;is_canceled\&quot;].copy()&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# transform test set\n&quot;, 
    &quot;X_test_prep = full_pipeline_2.transform(X_test)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;final_model = rf_cv_2.best_estimator_\n&quot;, 
    &quot;final_model&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# predict test set\n&quot;, 
    &quot;final_predictions = final_model.predict(X_test_prep)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [ 
    &quot;# evaluate predictions\n&quot;, 
    &quot;display_evaluation(y_test, final_predictions)&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&gt; #### Resources:\n&quot;, 
    &quot;&gt; 1. Hotel Booking Demand Dataset &lt;a href=\&quot;https://www.kaggle.com/jessemostipak/hotel-booking-demand\&quot;\n&quot;, 
    &quot;&gt; title=\&quot;Kaggle\&quot;&gt;link&lt;/a&gt;\n&quot;, 
    &quot;&gt; 2. Hotel Booking Demand Article &lt;a href=\&quot;https://www.sciencedirect.com/science/article/pii/S2352340918315191\&quot;\n&quot;, 
    &quot;&gt; title=\&quot;Article\&quot;&gt;link&lt;/a&gt;\n&quot;, 
    &quot;&gt; 3. Average Daily Rate Article &lt;a href=\&quot;https://www.investopedia.com/terms/a/average-daily-rate.asp\&quot;\n&quot;, 
    &quot;&gt; title=\&quot;Investopedia\&quot;&gt;link&lt;/a&gt;\n&quot;, 
    &quot;&gt; 4. Random Forest Article &lt;a href=\&quot;https://towardsdatascience.com/an-implementation-and-explanation-of-the-random-forest-in-python-77bf308a9b76\&quot; title=\&quot;towardsdatascience\&quot;&gt;link&lt;/a&gt;&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;&lt;a id='section_b'&gt;&lt;/a&gt;&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%% md\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;## Section B: Using Different ML Techniques to Improve Prediction Results&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%% md\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;*\&quot;If we have a project, and you're saying 'okay I can do that'. That's not the project we want. The projects that say [...]\n&quot;, 
    &quot;I don't know how to do that. Those are the things we want because through that curiosity you'll reach a level that\n&quot;, 
    &quot;you didn't think was possible.\&quot;* -Kobe Bryant&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%% md\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;In this second part, I will attempt to improve the results of my previous project by\n&quot;, 
    &quot;using the knowledge and skills I have gained the past several months.\n&quot;, 
    &quot;\n&quot;, 
    &quot;How I plan to achieve this task:\n&quot;, 
    &quot;\n&quot;, 
    &quot;I am a firm believer in learning from my past mistakes which is why\n&quot;, 
    &quot;I will acknowledge the vital ones I made in this project, and correct them.\n&quot;, 
    &quot;\n&quot;, 
    &quot;Additionally, I will select a few promising new methods to implement and explain why I chose them.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%% md\n&quot; 
    } 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;code&quot;, 
   &quot;execution_count&quot;: null, 
   &quot;outputs&quot;: [], 
   &quot;source&quot;: [], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;pycharm&quot;: { 
     &quot;name&quot;: &quot;#%%\n&quot; 
    } 
   } 
  } 
 ], 
 &quot;metadata&quot;: { 
  &quot;kernelspec&quot;: { 
   &quot;name&quot;: &quot;pycharm-822448ac&quot;, 
   &quot;language&quot;: &quot;python&quot;, 
   &quot;display_name&quot;: &quot;PyCharm (2SA-DS-Assignments)&quot; 
  }, 
  &quot;language_info&quot;: { 
   &quot;codemirror_mode&quot;: { 
    &quot;name&quot;: &quot;ipython&quot;, 
    &quot;version&quot;: 2 
   }, 
   &quot;file_extension&quot;: &quot;.py&quot;, 
   &quot;mimetype&quot;: &quot;text/x-python&quot;, 
   &quot;name&quot;: &quot;python&quot;, 
   &quot;nbconvert_exporter&quot;: &quot;python&quot;, 
   &quot;pygments_lexer&quot;: &quot;ipython2&quot;, 
   &quot;version&quot;: &quot;2.7.6&quot; 
  } 
 }, 
 &quot;nbformat&quot;: 4, 
 &quot;nbformat_minor&quot;: 0 
}</span></pre>
</body>
</html>